#!/bin/sh
#
#  write_local_variables
#
# Usage: write_local_variables
write_local_variables() {

    logmsg
    logmsg "write_local_variables"

    # pass all variables set here on to the hostname.sh script
    # rm -f /tmp/variables.txt

    echo "HOSTNAME=$HOSTNAME"                   >> /tmp/variables.txt || shellout
    echo "DOMAINNAME=$DOMAINNAME"               >> /tmp/variables.txt

    echo "DEVICE=$DEVICE"                       >> /tmp/variables.txt
    echo "IPADDR=$IPADDR"                       >> /tmp/variables.txt
    echo "NETMASK=$NETMASK"                     >> /tmp/variables.txt
    echo "NETWORK=$NETWORK"                     >> /tmp/variables.txt
    echo "BROADCAST=$BROADCAST"                 >> /tmp/variables.txt

    echo "GATEWAY=$GATEWAY"                     >> /tmp/variables.txt
    echo "GATEWAYDEV=$GATEWAYDEV"               >> /tmp/variables.txt

    echo "IMAGESERVER=$IMAGESERVER"             >> /tmp/variables.txt
    echo "IMAGENAME=$IMAGENAME"                 >> /tmp/variables.txt
    echo "DISK0=$DISK0"                         >> /tmp/variables.txt
 
} # END write_local_variables

disk_size ()
{
local DISK_SIZE
local DISK_SIZE2

PARTED_V=`parted -v | sed -e "s:GNU Parted ::"`

# Get the size of the destination disk so that we can make the partitions fit properly.
case ${PARTED_V} in
    1.6.?)
	DISK_SIZE=`parted -s $DISK0 print | grep 'Disk geometry for' | sed 's/^.*-//g' | sed 's/\..*$//' | sed 's/ //' `
	DISK_SIZE2=`parted -s ${DISK0}2 print | grep 'Disk geometry for' | sed 's/^.*-//g' | sed 's/\..*$//' | sed 's/ //' `
	;;
    1.6.2?*)
	DISK_SIZE=`parted -s $DISK0 unit MB print | grep 'Disk geometry for' | sed 's/^.*-//g' | sed 's/\..*$//' | sed 's/MB//' | sed 's/ //' `
	DISK_SIZE2=`parted -s ${DISK0}2 unit MB print | grep 'Disk geometry for' | sed 's/^.*-//g' | sed 's/\..*$//' | sed 's/MB//' | sed 's/ //' `
	;;	
    *)
	DISK_SIZE=`parted -s $DISK0 unit MB print | grep 'Disk ' | sed 's/^.*: //g' | sed 's/MB.*$//' | sed 's/MB//' | sed 's/ //' `
	DISK_SIZE2=`parted -s ${DISK0}2 unit MB print | grep 'Disk ' | sed 's/^.*: //g' | sed 's/MB.*$//' | sed 's/MB//' | sed 's/ //' `
	;;	
esac	

# DISK_SIZE2=$(echo "scale=3; (($DISK_SIZE * $hda2_ps / 100))" | bc)

echo "DISK_SIZE=$DISK_SIZE"		>> /tmp/variables.txt
echo "DISK_SIZE2=$DISK_SIZE2"		>> /tmp/variables.txt

}

mount_pseudofs()
{
    mount -o bind /dev /a/dev
    mount -o bind /sys /a/sys
    mount -o bind /proc /a/proc
}

getimage_aria_bm_local(){
    
    echo "getimage_aria_bm_local"
    
    local METHOD=$1
    
    if [ -z ${IMAGENAME_LIST} ]
    then
	getimage_aria_bm_image "${METHOD}" "${IMAGENAME}"
    else
	for i in ${IMAGENAME_LIST}
	do
	    getimage_aria_bm_image "${METHOD}" "${i}"
	done
    fi
}

getimage_aria_bm_image_dirty(){
    
    echo "getimage_aria_bm_image_dirty"    

    local METHOD=$1
    local IMAGENAME_CURRENT=$2
    
    echo "IMAGENAME_CURRENT=${IMAGENAME_CURRENT}"

    local BASENAME="${TORRENTS_DIR}/image-${IMAGENAME_CURRENT}"
    local tarball="image-${IMAGENAME_CURRENT}.tar.gz"

    if [ -f "${BASENAME}.tar.gz.${METHOD}" ]
    then
        tarball="image-${IMAGENAME_CURRENT}.tar.gz"
        compress="z"
    elif [ -f "${BASENAME}.tar.${METHOD}" ]
    then
        tarball="image-${IMAGENAME_CURRENT}.tar"
        compress=""
    else
        logmsg ""
        logmsg "There is no ${METHOD} file available for image ${IMAGENAME_CURRENT} in directory ${TORRENTS_DIR}"
        logmsg ""
        shellout
    fi

    logmsg "Starting download tarball ${tarball} via ${METHOD} to location ${STAGING}"

    ## Get file via aria

    logmsg "/usr/bin/aria2c --enable-rpc --human-readable=false --dir $STAGING ${TORRENTS_DIR}/${tarball}.${METHOD}"
    /usr/bin/aria2c --enable-rpc --human-readable=false --dir $STAGING "${TORRENTS_DIR}/${tarball}.${METHOD}" &> /tmp/aria.log &

    ## Extracting the image
    logmsg "Extracting image from ${tarball}"
    cd /a/ || shellout

    p_comment 0 "Unpacking image file: ${STAGING}/${tarball}"

    case $compress in
	"z")
		zcat ${STAGING}/${tarball} | tar -px${VERBOSE_GETIMAGE_OPT}f -
	;;
	*)
		tar -px${VERBOSE_GETIMAGE_OPT}f ${STAGING}/${tarball}
	;;
    esac

   rm -f ${STAGING}/${tarball}
}

getimage_aria_bm_image(){
    
    local METHOD=$1
    local IMAGENAME_CURRENT=$2
    
    echo "IMAGENAME_CURRENT=${IMAGENAME_CURRENT}"

    local BASENAME="${TORRENTS_DIR}/image-${IMAGENAME_CURRENT}"

    killall -9 aria2c
    killall -9 aria2c
    killall -9 aria2c

    if [ -f "${BASENAME}.tar.gz.${METHOD}" ]
    then
        tarball="image-${IMAGENAME_CURRENT}.tar.gz"
        compress="z"
    elif [ -f "${BASENAME}.tar.${METHOD}" ]
    then
        tarball="image-${IMAGENAME_CURRENT}.tar"
        compress=""
    else
        logmsg ""
        logmsg "There is no ${METHOD} file available for image ${IMAGENAME_CURRENT} in directory ${TORRENTS_DIR}"
        logmsg ""
        shellout
    fi

    if [ -z $STAGING ]
    then
        logmsg "aria_autodetect_staging_dir"
	SIZE=$(aria_getsize $METHOD ${TORRENTS_DIR}/${tarball}.${METHOD})
	STAGING=$(aria_autodetect_staging_dir $SIZE)
	if [ -z $STAGING ]
	then
	   logmsg ""
	   logmsg "Error: Cannot find a staging directory to save file: $tarball"
	   logmsg "Increase the size of your TMPFS or use rsync"
	   logmsg ""
	   shellout
	fi
    fi

    logmsg "Starting download tarball ${tarball} via ${METHOD} to location ${STAGING}"

    if [ "x$METHOD" = "xbittorrent" ]
    then
	logmsg "--> INFO: Don't forget to start /etc/init.d/systemimager-server-bittorrent on the image server"
    fi

    ## Get file via aria
    aria_get_file "${TORRENTS_DIR}/${tarball}.${METHOD}" $STAGING

    ## Extracting the image
    logmsg "Extracting image from ${tarball}"
    cd /a/ || shellout

    p_comment 0 "Unpacking image file: ${STAGING}/${tarball}"

    case $compress in
	"z")
		zcat ${STAGING}/${tarball} | tar -px${VERBOSE_GETIMAGE_OPT}f -
	;;
	*)
		tar -px${VERBOSE_GETIMAGE_OPT}f ${STAGING}/${tarball}
	;;
    esac

   rm -f ${STAGING}/${tarball}
   unset tarball
}

getimage_local(){

    logmsg ""
    logmsg "Getting image via protocol: $PROTOCOL"
    logmsg "" 
   
    ## Default VERBOSE level for getimage
    #
    VERBOSE_GETIMAGE_OPT=""

    ## To support systemimager install script option
    # 
    case "$VERBOSE_OPT" in
        "v")
            VERBOSE_GETIMAGE_OPT="v"
        ;;
    esac 
    
    ## Set the verbose flag for the getimage command
    #
    if [ $VERBOSE_LEVEL -ge "256" ]
    then  
        VERBOSE_GETIMAGE_OPT="v"
    fi

   case "$PROTOCOL" in
       "bittorrent")
           getimage_aria_bm_local torrent
       ;;
       "metalink")
           getimage_aria_bm_local metalink
       ;;
       "http"|"ftp")
           getimage_aria_hf $URL
       ;;
       *)
          export PROTOCOL=rsync
          save_param PROTOCOL rsync
          getimage_rsync
       ;;
    esac

}
grub2_install_local()
{
    chroot_mount_system_fs
    mount_pseudofs

    if [ $# -lt 1 ]
    then
        logmsg
        logmsg "Must specify a disk device, eg $DISK0 or /dev/sda"
        logmsg
        shellout
    fi
    target=$1

    logmsg "Using GRUB2 install method! :: $target"

    logmsg "grub2 install"
#    chroot /a /bin/bash
#    /usr/sbin/grub2-mkconfig -o /boot/grub2/grub.cfg
#    /usr/sbin/grub2-install --no-floppy $target
#    exit

    logmsg "chroot /a /usr/sbin/grub2-install --no-floppy $target"
    chroot /a /usr/sbin/grub2-install --no-floppy $target

    if [ -d /a/boot/grub2 ]
    then
	logmsg "/usr/sbin/grub2-mkconfig -o /boot/grub2/grub.cfg"
	chroot /a /usr/sbin/grub2-mkconfig -o /boot/grub2/grub.cfg
    fi

    if [ -d /a/boot/grub ]
    then
	logmsg "/usr/sbin/grub2-mkconfig -o /boot/grub/grub.cfg"
	chroot /a /usr/sbin/grub2-mkconfig -o /boot/grub/grub.cfg
    fi

}

grub1_install()
{
    chroot_mount_system_fs                                                                                                                                   
    mount_pseudofs

#    if [ $# -lt 1 ]
#    then
#        logmsg
#        logmsg "Must specify a disk device, eg $DISK0 or /dev/sda"
#        logmsg
#        shellout
#    fi
#    target=$1

#    logmsg "Using GRUB2 install method! :: $target"

    logmsg "grub1 install"

    # umount /a/boot
    # mount -o bind /dev /a/dev
    
chroot /a/ /sbin/grub --batch <<EOL || shellout
root (hd0,3)
setup (hd0)
quit
EOL
} # END grub1_install

# Checking hardware profile
check_profile ()
{

#export SFDISK_OPTIONS=

case ${HOSTNAME} in
    dk1n[456]?)
	# export HARDWARECLASS="scenic-x102 video_sis scr_1280x1024 scr_auto"
	# export HARDWARE_OPT="--exclude=/usr/share/doc/*"
	export HARDWARECLASS="scenic-x102 video_vesa scr_1280x1024 scr_auto"
	export GRUB=grub1
	export LINUX_IMAGENAME=centos6
	;;	
    dk2n4?)
	export HARDWARECLASS="scenic-x102 video_vesa scr_1280x1024 scr_auto"
	# export HARDWARE_OPT="--exclude=/usr/share/doc/*"
	export GRUB=grub1
	export LINUX_IMAGENAME=centos6
	;;	
    dk2n2?)
	export HARDWARECLASS="ga-8i945gmf video_ati.x550 scr_1280x1024 scr_auto disk_ide"
	export GRUB=grub1
	export LINUX_IMAGENAME=centos6
	;;
    dk2n*)
	export HARDWARECLASS="i865 net_e100 video_nvidia scr_1280x1024 scr_auto"
	export GRUB=grub1
	export LINUX_IMAGENAME=centos6
	;;
#    dk2n[45]?)
#	export HARDWARECLASS="gem667 net_rtl8139 video_i810 scr_1024x768 monitor_greenwood"
#	export SFDISK_OPTIONS="-H 16 -S 255 -C 19158"
#	export HARDWARE_OPT="--exclude=/usr/share/doc/*"
#	export GRUB=grub2
#	export LINUX_IMAGENAME=fedora
#	;;
#    dk2n8?)
#	export HARDWARECLASS="simlh net_rtl8139 video_sis650 video_sis scr_1024x768 monitor_greenwood"
#	export HARDWARE_OPT="--exclude=/usr/share/doc/*"
#	export LINUX_IMAGENAME=fedora
#	;;
#    dk2n*)
#	export HARDWARECLASS="formoza net_sis900 video_sis scr_1024x768 scr_auto"
#	export LINUX_IMAGENAME=fedora
#	;;
    dk4n00|dk6n00)
	export HARDWARECLASS="chipset_intel net_rtl8168 video_nvidia-nonfree sound_rltk-hda scr_1280x1024_dual_nvidia-nonfree massstorage_intel5ahci"
	export GRUB=grub2
	;;
    dk6n[34]*)
	export HARDWARECLASS="chipset_intel video_intel scr_auto"
	export GRUB=grub2
	;;
    dk3n*|dk6n*|dk7n*)
	export HARDWARECLASS="chipset_intel net_rtl8168 video_ati sound_rltk-hda scr_1280x1024 scr_auto massstorage_intel5ahci"
	export GRUB=grub2
	;;
    dk4n*)
	export HARDWARECLASS="chipset_intel net_rtl8168 video_ati sound_rltk-hda scr_1920x1080 scr_auto massstorage_intel5ahci"
	export GRUB=grub2
	;;
#    dk3n7?)
#	export HARDWARECLASS="gem667 net_3com video_i810 scr_1024x768 monitor_greenwood"
#	export HARDWARE_OPT="--exclude=/usr/share/doc/*"
#	export GRUB=grub1
#	;;
    dk5n*)
	export HARDWARECLASS="p4titan+nvidia+21monitor video_nvidia net_e100 scr_1600x1200 scr_auto boot_win_first"
	export GRUB=grub2
	;;
#    dk7n2?|dk6n2?)
#	export HARDWARECLASS="ga-8i945gmf video_ati scr_1280x1024"
#	export GRUB=grub2
#	;;
#    dk7n2?)
#	export HARDWARECLASS="ga-8i945gmf video_ati.x550 scr_1280x1024 scr_auto disk_ide"
#	export GRUB=grub2
#	export LINUX_IMAGENAME=fedora
#	;;
#    dk7n*)
#	export HARDWARECLASS="p4titan+nvidia+21monitor video_nvidia net_e100 scr_1600x1200"
#	export GRUB=grub2
#	;;
#    dk6n*)
#	export HARDWARECLASS="p4titan+nvidia video_nvidia net_e100 scr_1280x1024"
#	export GRUB=grub2
#	;;
#    dk7n*)
#	export HARDWARECLASS="i865 net_e100 video_nvidia scr_1280x1024 scr_auto"
#	export GRUB=grub2
#	export LINUX_IMAGENAME=fedora
#	;;
    dk116n1?)
	# dc7800
	export HARDWARECLASS="mb_intel sound_adihd net_e1000 video_nvidia scr_1280x1024 boot_win_first video_nvidia-setup dc7800 video_nvidia-nonfree"
	export GRUB=grub2
#	export NORMGRUB=1
	export LINUX_IMAGENAME=fedora
	;;
    dk116n2?)
	# dx7400
	export HARDWARECLASS="mb_intel sound_rltk-hda net_bcm5700 video_nvidia scr_1280x1024 scr_auto boot_win_first video_nvidia-setup"
	export GRUB=grub2
#	export NORMGRUB=1
	export LINUX_IMAGENAME=fedora
	;;
    dk284n*|dk286n*)
	export HARDWARECLASS="net_rtl8168 video_nvidia scr_1280x1024"
	export PARTIMAGE_NAME="dk286.partimg.gz.000"
	;;
    dk303n*)
	export HARDWARECLASS="winonly net_rtl8168 video_nvidia scr_1280x1024"
#	export HARDWARECLASS="winonly net_sis900 video_nvidia scr_1024x768"
#	export PARTIMAGE_NAME="dk286.partimg.gz.000"
	;;
    *)
	shellout
	;;
esac || shellout 

} # END chek_profile
# Set partition size
set_partitioning ()
{

echo "HARDWARECLASS=" ${HARDWARECLASS}

case ${HARDWARECLASS} in
    vectra|old+3c509)
	hda1_ps=97
	hda2_ps=0
	hda3_ps=3	
	hda5_ps=1
	hda6_ps=1
	hda4_ps=1
	;;
    acer*)
	hda1_ps=96
	hda2_ps=2.5
	hda3_ps=1	
	hda5_ps=0.5
	hda6_ps=0.5
	hda4_ps=0.5
	;;
    *)
	hda1_ps=35	# Windows # razbivka so 2-go sectora
	hda2_ps=12	# AFS
	hda3_ps=48	# Extended
	hda5_ps=44	# root
	hda6_ps=4	# swap	
	hda4_ps=4	# boot
	#
	boot_ps=4	# boot
	swap_ps=4	# swap
	windows_ps=35	# windows
	afscache_ps=10	# AFS cache
	;;
esac || shellout 

#case ${HOSTNAME} in
#    dk116n*)
#	hda1_ps=30	# Windows
#	hda2_ps=18	# Empty
#	hda3_ps=48	# Extended
#	hda5_ps=44	# root
#	hda6_ps=4	# swap	
#	hda4_ps=4	# boot
#	;;
#    *)
#	hda1_ps=40	# Windows
#	hda2_ps=8	# Empty
	hda3_ps=48	# Extended
#	hda5_ps=44	# root
#	hda6_ps=4	# swap	
#	hda4_ps=4	# boot
#	;;
#esac || shellout 

} # END set_partitioning

mount_linux() {

    if [ "$LINUX_MOUNTED" == "1" ]
    then
	echo "Linux already mounted"
    else
	mkdir -p /linux
	mount -t ext4 ${DISK0}8 /linux
	mount -o bind /dev /linux/dev
	mount -o bind /sys /linux/sys
	mount -o bind /proc /linux/proc

	export LINUX_MOUNTED="1"
    fi
	
}

# Unattend prepare
unattend_prepare_win10() {

echo "sed /a/netinst/AutoUnattend.xml"
sed -e "s:@HOSTNAME@:$HOSTNAME:g" /a/netinst/AutoUnattend.xml > /a/netinst/unattend.tmp || shellout
cp -f /a/netinst/unattend.tmp /a/netinst/AutoUnattend.xml || shellout
rm /a/netinst/unattend.tmp || shellout

#echo "sed /a/netinst/sysprep.inf"
#sed -e "s:@HOSTNAME@:$HOSTNAME:g" /a/netinst/sysprep.inf > /a/netinst/sysprep.tmp || shellout
#cp -f /a/netinst/sysprep.tmp /a/netinst/sysprep.inf || shellout
#rm /a/netinst/sysprep.tmp || shellout

echo "config /netinst/AutoUnattend.xml"
cd /a/netinst
. /scripts/unattend-xml.sh

# cp /a/netinst/sysprep.inf /a/sysprep/

mv /a/unattended/* /a/

cd /

}

save_and_clean_mbr_win10 ()
{
    dd if=${DISK0} of=/a/netinst/mbr.img count=1 bs=446 || shellout
    dd if=/dev/zero of=${DISK0} bs=446 count=1
#    /a/ms-sys -m ${DISK0} || shellout
}

create_filesystem_win10(){

    echo "Creating partition for windows on ${DISK0}:"
    
    mount_linux

    chroot /linux /sbin/sfdisk --part-type ${DISK0} 1 0x0c
    chroot /linux /sbin/sfdisk --part-type ${DISK0} 5 0x0c

    chroot /linux /usr/sbin/mkfs.vfat -F 32 ${DISK0}1
    chroot /linux /usr/sbin/mkfs.vfat -F 32 ${DISK0}5

#    echo "parted -s -- ${DISK0} set 1 boot on || shellout"
#    parted -s -- ${DISK0} set 1 boot on || shellout
#    parted -s -- ${DISK0} mkfs 1 fat32 || shellout

#    echo "mkdosfs -F 32 ${DISK0}1 || shellout"
#    /scripts/bin/mkdosfs -F 32 ${DISK0}1 || shellout
    # parted -s -- ${DISK0} resize 1
}

boot_disk_prepare_win10() {

    mount_linux
    
    chroot /linux /usr/bin/syslinux ${DISK0}1

    cp -R /a/winpe/* /c/	
}

# Unattend prepare

winxp_unattend_prepare() {

echo "sed /a/netinst/unattend.txt"
sed -e "s:@HOSTNAME@:$HOSTNAME:g" /a/netinst/unattend.txt > /a/netinst/unattend.tmp || shellout
cp -f /a/netinst/unattend.tmp /a/netinst/unattend.txt || shellout
rm /a/netinst/unattend.tmp || shellout

echo "sed /a/netinst/sysprep.inf"
sed -e "s:@HOSTNAME@:$HOSTNAME:g" /a/netinst/sysprep.inf > /a/netinst/sysprep.tmp || shellout
cp -f /a/netinst/sysprep.tmp /a/netinst/sysprep.inf || shellout
rm /a/netinst/sysprep.tmp || shellout

echo "config /netinst/unattend.txt"
cd /a/netinst
. /scripts/unattend.sh

cp /a/netinst/sysprep.inf /a/sysprep/

cd /

}

save_and_clean_mbr ()
{
    dd if=${DISK0} of=/a/netinst/mbr.img count=1 bs=512 || shellout
    /a/ms-sys -m ${DISK0} || shellout
}

create_filesystem_win(){

    echo "Creating partition ${DISK0}1:"

#    echo "parted -s -- ${DISK0} set 1 boot on || shellout"
#    parted -s -- ${DISK0} set 1 boot on || shellout
#    parted -s -- ${DISK0} mkfs 1 fat32 || shellout

    echo "mkdosfs -F 32 ${DISK0}1 || shellout"
    /scripts/bin/mkdosfs -F 32 ${DISK0}1 || shellout
    # parted -s -- ${DISK0} resize 1
}


