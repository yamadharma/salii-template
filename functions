#!/bin/sh
#
# This file is part of SALI
#
# SALI is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# SALI is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with SALI.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright 2010-2015 SURFsara

###
# $Id$
# $URL$
###

###
# Usage: disks_detect_lscsi
#
# Detect all disks using the lsscsi command
###
disks_detect_lsscsi(){

    lsscsi --transport 2>/dev/null | while read line
    do
        if [ -n "$(echo $line|grep -i 'cd')" ]
        then
            continue
        fi

        RESULT=$(echo $line | awk '/\/dev/ {print $NF}')
        if [ -n "${RESULT}" ]
        then
            echo $RESULT
        fi
    done
}

###
# Usage: disks_detect_dev
#
# Detect all disks by looking at the /dev/disk/*
# method (fallback for lscsci)
###
disks_detect_dev(){

    DISKS=""

    ## Loop trough all possible /dev/disks/*/*
    ls -1 /dev/disk/ | while read disk_by
    do
        ## Just to be sure the location exists
        if [ -e "/dev/disk/${disk_by}" ]
        then
            ## Then find all disks (not the actual partitions)
            ls -1 /dev/disk/$disk_by | grep -v part | while read disk
            do
                ## Use realpath to find out the /dev/* device
                real_disk=$(realpath /dev/disk/$disk_by/$disk)
                
                ## Is it realy a disk?
                if [ -n "$(cat /proc/partitions | grep $(basename $real_disk))" ]
                then
                    match=$(echo $DISKS | grep -c $real_disk)
                    case "${match}" in
                        0)
                            DISKS="${DISKS}${real_disk} "
                            echo $real_disk
                        ;;
                    esac
                fi
            done
        fi
    done
}

###
# Usage: disks_detect [order]
#
# Detect all disk in the system, optional supply
# order, such as: sd,hd
###
disks_detect(){
    DISKORDER=$1
    ALLDISKS=$(disks_detect_lsscsi)

    if [ -z "${ALLDISKS}" ]
    then
        ALLDISKS=$(disks_detect_dev)
    fi

    if [ -z "${ALLDISKS}" ]
    then
        return 1
    fi

    for disk in $DISKORDER
    do
        ## Just to be sure we only have the filename
        DISKNAME=$(basename $disk)
        CONTROLLER=false

        ## Assume i'ts a controller
        if [ ${#DISKNAME} -eq 2 ]
        then
            CONTROLLER=true
        fi

        ## Make sure we order the disks correct based on the length of the string, due to sdaa type of disks
        for udisk in $(echo $ALLDISKS | tr " " "\n" | awk '{ print length(), $1 | "sort" }' | awk '{print $2}')
        do
            ## Check of we already sorted the given udisk
            DONE=$(echo $SDISKS|grep -w $udisk)

            if [ -z "${DONE}" ]
            then
                ## Check if we can find a disk, when it's not a controller match the whole string
                if [ "${CONTROLLER}" == "true" ]
                then
                    found=$(echo $udisk | grep $disk)
                else
                    found=$(echo $udisk | grep -w $disk)
                fi

                ## If found, append to the sorted disk list
                if [ -n "${found}" ]
                then
                    SDISKS="$SDISKS $udisk"
                fi
            fi
        done
    done

    NUMDISKS=0
    for disk in $(echo $SDISKS)
    do
        eval "DISK${NUMDISKS}=${disk}"
        NUMDISKS=$(( $NUMDISKS + 1 ))
    done

    ## Instead of exporting, use the save_variables fucntion
    save_variables
}

###
# Usage: disks_prep <msdos|gpt> <disk> [disks]
#
# Prepare the disks for repartition for msdos or gpt layout
###
disks_prep(){
    LABEL=$1
    shift 1
    
    case "${1}" in
        all)
            ## We need some global variables
            . $SALI_VARIABLES_FILE
            for disknum in $(seq 0 $((NUMDISKS-1)))
            do
                eval d_name="\${DISK${disknum}}"
                DISKS="${DISKS}${d_name} "
            done
        ;;
        *)
            DISKS=$@
        ;;
    esac

    p_service "Preparing disk(s)"

    for disk in $DISKS
    do
        if [ $SALI_VERBOSE_LEVEL -ge 10 ]
        then
            p_comment 10 "/usr/sbin/parted -s -- ${disk} mklabel ${LABEL}"
        else
            p_comment 0 "setting disklabel ${LABEL} for ${disk}"
        fi

        if [ $SALI_VERBOSE_LEVEL -ge 256 ]
        then
            /usr/sbin/parted -s -- $disk mklabel $LABEL
        else
            /usr/sbin/parted -s -- $disk mklabel $LABEL >/dev/null 2>&1
        fi
    done
}

###
# Usage: disks_last_size <disk>
#
# Get the last size in MB of the disk
#
# Syntax required options:
#  disk       : specify the disk you wan't to edit
#
###
disks_last_size(){
    DISK=$1

    if [ -b "${DISK}" ]
    then
        LAST_SIZE=$(/usr/sbin/parted -s -- $DISK unit MB print free | tail -n2 | awk '/Free Space/ {print $1}' | sed 's/MB//g' | awk -F. '{print $1}')
        if [ -n "${LAST_SIZE}" ]
        then
            if [ -n "$(echo $LAST_SIZE|egrep "[0-9\.]+")" ]
            then
                echo $(echo "$LAST_SIZE + 1" | bc)
                return 0
            elif [ -n "$(echo $LAST_SIZE|grep kB)" ]
            then
                echo 0
                return 0
            fi
        fi
    fi

    return 1
}

###
# Usage: disks_cerate_partition <disk> <size> <type> [flag]
#
# Get the last size in MB of the disk
#
# Syntax required options:
#  disk       : specify the disk you wan't to edit
#
###
disks_create_partition(){
    ## We need to fetch the DISK label every time, because this could be changes per disk!
    DISK_LABEL=$(/usr/sbin/parted -s -- "${1}" print 2>/dev/null | awk '/Partition Table/ {print $NF}')
    LAST_SIZE=$(disks_last_size $1)

    case "${2}" in
        -1|100%)
            END_SIZE="-1"
        ;;
        *)
            END_SIZE=$(echo "$LAST_SIZE + $2" | bc )
        ;;
    esac


    case "${DISK_LABEL}" in
        gpt)
            p_comment 10 "/usr/sbin/parted -s -- ${1} mkpart primary ${LAST_SIZE}M ${END_SIZE}M"
            /usr/sbin/parted -s -- "${1}" mkpart primary "${LAST_SIZE}M" "${END_SIZE}M"
        ;;
        ## Yes I know there is some redunand code between msdos and gpt, but this make it more readable
        msdos)
            PART_NUM=$(/usr/sbin/parted -s -- "${1}" print 2>/dev/null | awk '/^ [0-9].*/ {print $1}' | tail -n1)
            if [ -z "${PART_NUM}" ]
            then
                PART_NUM=0
            fi

            if [ $PART_NUM -eq 2 ]
            then
                p_comment 10 "/usr/sbin/parted -s -- ${1} mkpart extended ${LAST_SIZE}M -1"
                /usr/sbin/parted -s -- "${1}" mkpart extended "${LAST_SIZE}M" -1
                PART_NUM=$(/usr/sbin/parted -s -- "${1}" print 2>/dev/null | awk '/^ [0-9].*/ {print $1}' | tail -n1)
                EXTENDED_LAST_SIZE=$LAST_SIZE
            fi

            if [ $PART_NUM -ge 2 ]
            then
                case "${2}" in
                    -1|100%)
                        END_SIZE="-1"
                    ;;
                    *)
                        END_SIZE=$(echo "$EXTENDED_LAST_SIZE + $2" | bc )
                    ;;
                esac
                p_comment 10 "/usr/sbin/parted -s -- ${1} mkpart logical ${EXTENDED_LAST_SIZE}M ${END_SIZE}M"
                /usr/sbin/parted -s -- "${1}" mkpart logical "${EXTENDED_LAST_SIZE}M" "${END_SIZE}M"
                EXTENDED_LAST_SIZE=$END_SIZE
            else
                p_comment 10 "/usr/sbin/parted -s -- ${1} mkpart primary ${LAST_SIZE}M ${END_SIZE}M"
                /usr/sbin/parted -s -- "${1}" mkpart primary "${LAST_SIZE}M" "${END_SIZE}M"
            fi
        ;;
    esac
        

    if [ "${3}" != "none" ]
    then
        PART_NUM=$(/usr/sbin/parted -s -- "${1}" print 2>/dev/null | awk '/^ [0-9].*/ {print $1}' | tail -n1)
        p_comment 10 "/usr/sbin/parted -s -- ${1} set ${PART_NUM} $3 on"
        /usr/sbin/parted -s -- "${1}" set "${PART_NUM}" "${3}" on
    fi
}

###
# Usage: disks_format <disk> <type>
#
# Create partitions on specific disks
#
# Syntax required options:
#  disk       : specify the disk you wan't to edit
#  type       : filesystem type
#
# Syntax optional options:
#  label=boot                           the label of the partition
#  options="-I 128"                     check the man page mkfs.<fstype> for the options
#
###
disks_format(){
    DISK=$1
    TYPE=$2
    LABEL=$(echo $3|awk -F'=' '{print $NF}')
    shift 3
    OPTIONS=$(echo $@|awk -F'=' '{print $NF}')

    if [ -n "${LABEL}" ]
    then
        LABEL="-L ${LABEL}"
    fi

    if [ "$SALI_VERBOSE_LEVEL" -ne 256 ]
    then
        QUIET="-q"
    else
        QUIET=""
    fi

    case "${TYPE}" in
        ext2)
            p_comment 10 "/sbin/mkfs.ext2 ${DISK} ${LABEL} ${OPTIONS}"
            /sbin/mkfs.ext2 $DISK $LABEL $OPTIONS $QUIET
        ;;
        ext3)
            p_comment 10 "/sbin/mkfs.ext3 ${DISK} ${LABEL} ${OPTIONS}"
            /sbin/mkfs.ext3 $DISK $LABEL $OPTIONS $QUIET
        ;;
        ext4)
            p_comment 10 "/sbin/mkfs.ext4 ${DISK} ${LABEL} ${OPTIONS}"
            /sbin/mkfs.ext4 $DISK $LABEL $OPTIONS $QUIET
        ;;
        xfs)
            p_comment 10 "/sbin/mkfs.xfs ${DISK} ${LABEL} ${OPTIONS}"
            /sbin/mkfs.xfs $DISK $LABEL $OPTIONS $QUIET
        ;;
        swap)
            p_comment 10 "/sbin/mkswap ${DISK} ${LABEL} ${OPTIONS}"
            if [ "$SALI_VERBOSE_LEVEL" -ne 256 ]
            then
                /sbin/mkswap $DISK $LABEL $OPTIONS >/dev/null 2>&1
            else
                /sbin/mkswap $DISK $LABEL $OPTIONS
            fi
        ;;
    esac
}


###
# Usage: disks_part <disk> <mountpoint> <size> [options]
#
# Create partitions on specific disks
#
# Syntax required options:
#  disk       : specify the disk you wan't to edit
#  mountpoint : /<path>, swap, none, raid.<id>, pv.<id>
#  size       : specify size in MB (-1 means rest of disk)
#
# Syntax optional options:
#  type=<ext2|ext3|ext4|xfs|swap>       currently supported filesystems
#  flag=<bios_grub|lvm|raid>            which flag must be set on the partition
#                                       when using raid.<id> or lvm.<id> the flag
#                                       lvm or raid is optional!
#  label=boot                           the label of the partition
#  options="-I 128"                     check the man page mkfs.<fstype> for the options
#  dirperms=1777                        with which permissions must the mount directory be
#
###
disks_part() {
    set $(args $@)

    unset LABEL OPTIONS DIRPERMS ARGS

    TYPE=none
    FLAG=none
   
    IN_OPTIONS=0 
    DISK=$1
    MOUNTPOINT=$2
    SIZE=$3
    shift 3

    while [ $# -gt 0 ]
    do
        case "${1}" in
            type)
                TYPE="${2}"
                IN_OPTIONS=0
                shift 2
            ;;
            flag)
                FLAG="${2}"
                IN_OPTIONS=0
                shift 2
            ;;
            label)
                LABEL="${2}"
                IN_OPTIONS=0
                shift 2
            ;;
            options)
                OPTIONS="${2}"
                IN_OPTIONS=1
                shift 2
            ;;
            dirperms)
                DIRPERMS="${2}"
                IN_OPTIONS=0
                shift 2
            ;;
            *)
                if [ $IN_OPTIONS -eq 1 ]
                then
                    OPTIONS="${OPTIONS} ${1}"
                else
                    ARGS="${ARGS}${1} "
                fi
                shift 1
            ;;
        esac
    done

    ### Check if given label is supported, else show error
    case "${FLAG}" in
        bios_grub|none)
            ## Ok let's go
        ;;
        lvm|raid)
            p_comment 0 "Currently lvm|raid are not supported yet"
        ;;
        *)
            p_comment 0 "Given flag ${FLAG} is not supported (bios_grub|lvm|raid|none)"
            open_console error
        ;;
    esac

    p_service "Creating partition on disk ${DISK}"
    disks_create_partition $DISK $SIZE $FLAG
    PART_NUM=$(/usr/sbin/parted -s -- "${DISK}" print | awk '/^ [0-9].*/ {print $1}' | tail -n1)

    ## Check if given filesystem is supported, else show error
    case "${TYPE}" in
        ext2|ext3|ext4|xfs|swap|none)
            disks_format "${DISK}${PART_NUM}" "${TYPE}" "label=${LABEL}" "options=${OPTIONS}"
        ;;
        *)
            p_comment 0 "Given filesystem type ${TYPE} is not supported (ext2|ext3|ext4|xfs|swap)"
            open_console error
        ;;
    esac

    p_comment 0 "size: ${SIZE}, mount: ${MOUNTPOINT}, type: ${TYPE}"

    ## For verbose logging
    for var in FLAG LABEL OPTIONS DIRPERMS
    do
        eval var_value="\${${var}}"
        if [ -n "${var_value}" ]
        then
            p_comment 10 "$(echo $var | tr '[:upper:]' '[:lower:]'): ${var_value}"
        fi
    done
    
    mkdir -p /var/cache
    echo "$MOUNTPOINT ${DISK}${PART_NUM} $TYPE" >> /var/cache/mounts
}
# -*- mode:shell-script -*-
#
#  write_local_variables
#
# Usage: write_local_variables
write_local_variables() {

    logmsg
    logmsg "write_local_variables"

    # pass all variables set here on to the hostname.sh script
    # rm -f /tmp/variables.txt

    echo "HOSTNAME=$HOSTNAME"                   >> /tmp/variables.txt || shellout
    echo "DOMAINNAME=$DOMAINNAME"               >> /tmp/variables.txt

    echo "DEVICE=$DEVICE"                       >> /tmp/variables.txt
    echo "IPADDR=$IPADDR"                       >> /tmp/variables.txt
    echo "NETMASK=$NETMASK"                     >> /tmp/variables.txt
    echo "NETWORK=$NETWORK"                     >> /tmp/variables.txt
    echo "BROADCAST=$BROADCAST"                 >> /tmp/variables.txt

    echo "GATEWAY=$GATEWAY"                     >> /tmp/variables.txt
    echo "GATEWAYDEV=$GATEWAYDEV"               >> /tmp/variables.txt

    echo "IMAGESERVER=$IMAGESERVER"             >> /tmp/variables.txt
    echo "IMAGENAME=$IMAGENAME"                 >> /tmp/variables.txt
    echo "DISK0=$DISK0"                         >> /tmp/variables.txt
 
} # END write_local_variables

disk_size ()
{
local DISK_SIZE
local DISK_SIZE2

PARTED_V=`parted -v | sed -e "s:GNU Parted ::"`

# Get the size of the destination disk so that we can make the partitions fit properly.
case ${PARTED_V} in
    1.6.?)
	DISK_SIZE=`parted -s $DISK0 print | grep 'Disk geometry for' | sed 's/^.*-//g' | sed 's/\..*$//' | sed 's/ //' `
	DISK_SIZE2=`parted -s ${DISK0}2 print | grep 'Disk geometry for' | sed 's/^.*-//g' | sed 's/\..*$//' | sed 's/ //' `
	;;
    1.6.2?*)
	DISK_SIZE=`parted -s $DISK0 unit MB print | grep 'Disk geometry for' | sed 's/^.*-//g' | sed 's/\..*$//' | sed 's/MB//' | sed 's/ //' `
	DISK_SIZE2=`parted -s ${DISK0}2 unit MB print | grep 'Disk geometry for' | sed 's/^.*-//g' | sed 's/\..*$//' | sed 's/MB//' | sed 's/ //' `
	;;	
    *)
	DISK_SIZE=`parted -s $DISK0 unit MB print | grep 'Disk ' | sed 's/^.*: //g' | sed 's/MB.*$//' | sed 's/MB//' | sed 's/ //' `
	DISK_SIZE2=`parted -s ${DISK0}2 unit MB print | grep 'Disk ' | sed 's/^.*: //g' | sed 's/MB.*$//' | sed 's/MB//' | sed 's/ //' `
	;;	
esac	

# DISK_SIZE2=$(echo "scale=3; (($DISK_SIZE * $hda2_ps / 100))" | bc)

echo "DISK_SIZE=$DISK_SIZE"		>> /tmp/variables.txt
echo "DISK_SIZE2=$DISK_SIZE2"		>> /tmp/variables.txt

}

mount_pseudofs()
{
    mount -o bind /dev /a/dev
    mount -o bind /sys /a/sys
    mount -o bind /proc /a/proc
}

# -*- mode:shell-script -*-
getimage_aria_bm_local(){
    
    echo "getimage_aria_bm_local"
    
    local METHOD=$1
    
    if [ -z ${IMAGENAME_LIST} ]
    then
	getimage_aria_bm_image "${METHOD}" "${IMAGENAME}"
    else
	for i in ${IMAGENAME_LIST}
	do
	    getimage_aria_bm_image "${METHOD}" "${i}"
	done
    fi
}

getimage_aria_bm_image_dirty(){
    
    echo "getimage_aria_bm_image_dirty"    

    local METHOD=$1
    local IMAGENAME_CURRENT=$2
    
    echo "IMAGENAME_CURRENT=${IMAGENAME_CURRENT}"

    local BASENAME="${TORRENTS_DIR}/image-${IMAGENAME_CURRENT}"
    local tarball="image-${IMAGENAME_CURRENT}.tar.gz"

    if [ -f "${BASENAME}.tar.gz.${METHOD}" ]
    then
        tarball="image-${IMAGENAME_CURRENT}.tar.gz"
        compress="z"
    elif [ -f "${BASENAME}.tar.${METHOD}" ]
    then
        tarball="image-${IMAGENAME_CURRENT}.tar"
        compress=""
    else
        logmsg ""
        logmsg "There is no ${METHOD} file available for image ${IMAGENAME_CURRENT} in directory ${TORRENTS_DIR}"
        logmsg ""
        shellout
    fi

    logmsg "Starting download tarball ${tarball} via ${METHOD} to location ${STAGING}"

    ## Get file via aria

    logmsg "/usr/bin/aria2c --enable-rpc --human-readable=false --dir $STAGING ${TORRENTS_DIR}/${tarball}.${METHOD}"
    /usr/bin/aria2c --enable-rpc --human-readable=false --dir $STAGING "${TORRENTS_DIR}/${tarball}.${METHOD}" &> /tmp/aria.log &

    ## Extracting the image
    logmsg "Extracting image from ${tarball}"
    cd /a/ || shellout

    p_comment 0 "Unpacking image file: ${STAGING}/${tarball}"

    case $compress in
	"z")
		zcat ${STAGING}/${tarball} | tar -px${VERBOSE_GETIMAGE_OPT}f -
	;;
	*)
		tar -px${VERBOSE_GETIMAGE_OPT}f ${STAGING}/${tarball}
	;;
    esac

   rm -f ${STAGING}/${tarball}
}

getimage_aria_bm_image(){
    
    local METHOD=$1
    local IMAGENAME_CURRENT=$2
    
    echo "IMAGENAME_CURRENT=${IMAGENAME_CURRENT}"

    local BASENAME="${TORRENTS_DIR}/image-${IMAGENAME_CURRENT}"

    killall -9 aria2c
    killall -9 aria2c
    killall -9 aria2c

    if [ -f "${BASENAME}.tar.gz.${METHOD}" ]
    then
        tarball="image-${IMAGENAME_CURRENT}.tar.gz"
        compress="z"
    elif [ -f "${BASENAME}.tar.${METHOD}" ]
    then
        tarball="image-${IMAGENAME_CURRENT}.tar"
        compress=""
    else
        logmsg ""
        logmsg "There is no ${METHOD} file available for image ${IMAGENAME_CURRENT} in directory ${TORRENTS_DIR}"
        logmsg ""
        shellout
    fi

    if [ -z $STAGING ]
    then
        logmsg "aria_autodetect_staging_dir"
	SIZE=$(aria_getsize $METHOD ${TORRENTS_DIR}/${tarball}.${METHOD})
	STAGING=$(aria_autodetect_staging_dir $SIZE)
	if [ -z $STAGING ]
	then
	   logmsg ""
	   logmsg "Error: Cannot find a staging directory to save file: $tarball"
	   logmsg "Increase the size of your TMPFS or use rsync"
	   logmsg ""
	   shellout
	fi
    fi

    logmsg "Starting download tarball ${tarball} via ${METHOD} to location ${STAGING}"

    if [ "x$METHOD" = "xbittorrent" ]
    then
	logmsg "--> INFO: Don't forget to start /etc/init.d/systemimager-server-bittorrent on the image server"
    fi

    ## Get file via aria
    aria_get_file "${TORRENTS_DIR}/${tarball}.${METHOD}" $STAGING

    ## Extracting the image
    logmsg "Extracting image from ${tarball}"
    cd /a/ || shellout

    p_comment 0 "Unpacking image file: ${STAGING}/${tarball}"

    case $compress in
	"z")
		zcat ${STAGING}/${tarball} | tar -px${VERBOSE_GETIMAGE_OPT}f -
	;;
	*)
		tar -px${VERBOSE_GETIMAGE_OPT}f ${STAGING}/${tarball}
	;;
    esac

   rm -f ${STAGING}/${tarball}
   unset tarball
}

getimage_local(){

    logmsg ""
    logmsg "Getting image via protocol: $PROTOCOL"
    logmsg "" 
   
    ## Default VERBOSE level for getimage
    #
    VERBOSE_GETIMAGE_OPT=""

    ## To support systemimager install script option
    # 
    case "$VERBOSE_OPT" in
        "v")
            VERBOSE_GETIMAGE_OPT="v"
        ;;
    esac 
    
    ## Set the verbose flag for the getimage command
    #
    if [ $VERBOSE_LEVEL -ge "256" ]
    then  
        VERBOSE_GETIMAGE_OPT="v"
    fi

   case "$PROTOCOL" in
       "bittorrent")
           getimage_aria_bm_local torrent
       ;;
       "metalink")
           getimage_aria_bm_local metalink
       ;;
       "http"|"ftp")
           getimage_aria_hf $URL
       ;;
       *)
          export PROTOCOL=rsync
          save_param PROTOCOL rsync
          getimage_rsync
       ;;
    esac

}
# -*- mode:shell-script -*-
grub2_install_local()
{
    chroot_mount_system_fs
    mount_pseudofs

    if [ $# -lt 1 ]
    then
        logmsg
        logmsg "Must specify a disk device, eg $DISK0 or /dev/sda"
        logmsg
        shellout
    fi
    target=$1

    logmsg "Using GRUB2 install method! :: $target"

    logmsg "grub2 install"
#    chroot /a /bin/bash
#    /usr/sbin/grub2-mkconfig -o /boot/grub2/grub.cfg
#    /usr/sbin/grub2-install --no-floppy $target
#    exit

    logmsg "chroot /a /usr/sbin/grub2-install --no-floppy $target"
    chroot /a /usr/sbin/grub2-install --no-floppy $target

    if [ -d /a/boot/grub2 ]
    then
	logmsg "/usr/sbin/grub2-mkconfig -o /boot/grub2/grub.cfg"
	chroot /a /usr/sbin/grub2-mkconfig -o /boot/grub2/grub.cfg
    fi

    if [ -d /a/boot/grub ]
    then
	logmsg "/usr/sbin/grub2-mkconfig -o /boot/grub/grub.cfg"
	chroot /a /usr/sbin/grub2-mkconfig -o /boot/grub/grub.cfg
    fi

}

grub1_install()
{
    chroot_mount_system_fs                                                                                                                                   
    mount_pseudofs

#    if [ $# -lt 1 ]
#    then
#        logmsg
#        logmsg "Must specify a disk device, eg $DISK0 or /dev/sda"
#        logmsg
#        shellout
#    fi
#    target=$1

#    logmsg "Using GRUB2 install method! :: $target"

    logmsg "grub1 install"

    # umount /a/boot
    # mount -o bind /dev /a/dev
    
chroot /a/ /sbin/grub --batch <<EOL || shellout
root (hd0,3)
setup (hd0)
quit
EOL
} # END grub1_install

# -*- mode:shell-script -*-
# Checking hardware profile
check_profile ()
{

#export SFDISK_OPTIONS=

    case ${HOSTNAME} in
	dk1n[456]?)
	    export HARDWARECLASS="scenic-x102 video_vesa scr_1280x1024 scr_auto"
	    export GRUB=grub1
	    export LINUX_IMAGENAME=centos6
	    ;;	
	dk2n4?)
	    export HARDWARECLASS="scenic-x102 video_vesa scr_1280x1024 scr_auto"
	    # export HARDWARE_OPT="--exclude=/usr/share/doc/*"
	    export GRUB=grub1
	    export LINUX_IMAGENAME=centos6
	    ;;	
	dk2n2?)
	    export HARDWARECLASS="ga-8i945gmf video_ati.x550 scr_1280x1024 scr_auto disk_ide"
	    export GRUB=grub1
	    export LINUX_IMAGENAME=centos6
	    ;;
	dk2n*)
	    export HARDWARECLASS="i865 net_e100 video_nvidia scr_1280x1024 scr_auto"
	    export GRUB=grub1
	    export LINUX_IMAGENAME=centos6
	    ;;
	dk4n00|dk6n00)
	    export HARDWARECLASS="chipset_intel net_rtl8168 video_nvidia-nonfree sound_rltk-hda scr_1280x1024_dual_nvidia-nonfree massstorage_intel5ahci"
	    export GRUB=grub2
	    ;;
	dk3n[34]*|dk6n[34]*)
	    export HARDWARECLASS="chipset_intel video_intel scr_auto"
	    export GRUB=grub2
	    # export DISKLABEL=gpt
	    ;;
	dk3n*|dk6n*|dk7n*)
	    export HARDWARECLASS="chipset_intel net_rtl8168 video_ati sound_rltk-hda scr_1280x1024 scr_auto massstorage_intel5ahci"
	    export GRUB=grub2
	    ;;
	dk4n*)
	    export HARDWARECLASS="chipset_intel net_rtl8168 video_ati sound_rltk-hda scr_1920x1080 scr_auto massstorage_intel5ahci"
	    export GRUB=grub2
	    ;;
	dk5n*)
	    export HARDWARECLASS="p4titan+nvidia+21monitor video_nvidia net_e100 scr_1600x1200 scr_auto boot_win_first"
	    export GRUB=grub2
	    ;;
	dk116n1?)
	    # dc7800
	    export HARDWARECLASS="mb_intel sound_adihd net_e1000 video_nvidia scr_1280x1024 boot_win_first video_nvidia-setup dc7800 video_nvidia-nonfree"
	    export GRUB=grub2
	    export LINUX_IMAGENAME=fedora
	    ;;
	dk116n2?)
	    # dx7400
	    export HARDWARECLASS="mb_intel sound_rltk-hda net_bcm5700 video_nvidia scr_1280x1024 scr_auto boot_win_first video_nvidia-setup"
	    export GRUB=grub2
	    export LINUX_IMAGENAME=fedora
	    ;;
	dk284n*|dk286n*)
	    export HARDWARECLASS="net_rtl8168 video_nvidia scr_1280x1024"
	    export PARTIMAGE_NAME="dk286.partimg.gz.000"
	    ;;
	dk303n*)
	    export HARDWARECLASS="winonly net_rtl8168 video_nvidia scr_1280x1024"
	    ;;
	*)
	    shellout
	    ;;
    esac || shellout 
    
} # END chek_profile
# -*- mode:shell-script -*-
# Set partition size
set_partitioning ()
{
echo "HARDWARECLASS=" ${HARDWARECLASS}

case ${HARDWARECLASS} in
    vectra|old+3c509)
	hda1_ps=97
	hda2_ps=0
	hda3_ps=3	
	hda5_ps=1
	hda6_ps=1
	hda4_ps=1
	;;
    acer*)
	hda1_ps=96
	hda2_ps=2.5
	hda3_ps=1	
	hda5_ps=0.5
	hda6_ps=0.5
	hda4_ps=0.5
	;;
    *)
	hda1_ps=35	# Windows # razbivka so 2-go sectora
	hda2_ps=12	# AFS
	hda3_ps=48	# Extended
	hda5_ps=44	# root
	hda6_ps=4	# swap	
	hda4_ps=4	# boot
	#
	boot_ps=4	# boot
	swap_ps=4	# swap
	windows_ps=35	# windows
	afscache_ps=10	# AFS cache
	root_ps=46	# root
	;;
esac || shellout 

#case ${HOSTNAME} in
#    dk116n*)
#	hda1_ps=30	# Windows
#	hda2_ps=18	# Empty
#	hda3_ps=48	# Extended
#	hda5_ps=44	# root
#	hda6_ps=4	# swap	
#	hda4_ps=4	# boot
#	;;
#    *)
#	hda1_ps=40	# Windows
#	hda2_ps=8	# Empty
	hda3_ps=48	# Extended
#	hda5_ps=44	# root
#	hda6_ps=4	# swap	
#	hda4_ps=4	# boot
#	;;
#esac || shellout 

} # END set_partitioning

set_partition_numbers()
{
    if [ "$DISKLABEL" == "msdos" ]
    then
	windows_pn=1
	boot_pn=2
	windistro_pn=5
	afscache_pn=6
	swap_pn=7
	root_pn=8
    else # "$DISKLABEL" == "gpt"
	if [ "$UEFI" == "yes" ]
	then
	    uefi_pn=1
	    windows_pn=2
	    boot_pn=3
	    windistro_pn=4
	    afscache_pn=5
	    swap_pn=6
	    root_pn=7
	else
	    windows_pn=1
	    boot_pn=2
	    windistro_pn=4
	    afscache_pn=5
	    swap_pn=6
	    root_pn=7
	fi
    fi
}

set_disklabel_type()
{
    if [ "$DISKLABEL" == "gpt" ]; then
	DISKLABEL=gpt
    else
	DISKLABEL=msdos
    fi
    
    if [ "$UEFI" == "yes" ]; then
	DISKLABEL=gpt
    fi
}
# -*- mode:shell-script -*-

# Mount linux partitions
mount_linux() {
    if [ "$LINUX_MOUNTED" == "1" ]
    then
	echo "Linux already mounted"
    else
	mkdir -p /linux
	mount -t ext4 ${DISK0}${root_pn} /linux
	mount -o bind /dev /linux/dev
	mount -o bind /sys /linux/sys
	mount -o bind /proc /linux/proc
	mount -o bind /run /linux/run
	
	export LINUX_MOUNTED="1"
    fi
}

# Unattend prepare
unattend_prepare_win10() {
    
    echo "sed /a/netinst/AutoUnattend.xml"
    sed -e "s:@HOSTNAME@:$HOSTNAME:g" /a/netinst/AutoUnattend.xml > /a/netinst/unattend.tmp || shellout
    cp -f /a/netinst/unattend.tmp /a/netinst/AutoUnattend.xml || shellout
    rm /a/netinst/unattend.tmp || shellout
    
    echo "config /netinst/AutoUnattend.xml"
    cd /a/netinst
    . /scripts/unattend-xml.sh
 
    mv /a/unattended/* /a/
    
    cd /
}

save_and_clean_mbr_win10 ()
{
    mount_linux	
    dd if=${DISK0} of=/a/netinst/mbr.img count=1 bs=446 || shellout
    # dd if=/dev/zero of=${DISK0} bs=446 count=1
    chroot /linux /usr/bin/ms-sys -7 ${DISK0} || shellout
}

create_filesystem_win10(){
    
    echo "Creating partition for windows on ${DISK0}:"
    
    mount_linux

    if [ "$DISKLABEL" == "msdos" ]                                                                                                                                                           
    then                                                                                                                                                                                     
	chroot /linux /sbin/sfdisk --part-type ${DISK0} ${windows_pn} 0x0c
	chroot /linux /sbin/sfdisk --part-type ${DISK0} ${windistro_pn} 0x0c
    else # "$DISKLABEL" == "gpt"
	chroot /linux /usr/sbin/sgdisk --typecode=${windows_pn}:0x0700 ${DISK0}
	chroot /linux /usr/sbin/sgdisk --typecode=${windistro_pn}:0x0700 ${DISK0}

	chroot /linux /usr/sbin/sgdisk --typecode=${grub_pn}:0x8300 ${DISK0}
	chroot /linux /usr/sbin/sgdisk --typecode=${root_pn}:0x8300 ${DISK0}
	chroot /linux /usr/sbin/sgdisk --typecode=${afscache_pn}:0x8300 ${DISK0}
	chroot /linux /usr/sbin/sgdisk --typecode=${swap_pn}:0x8300 ${DISK0}
    fi


    chroot /linux /usr/sbin/mkfs.vfat -F 32 ${DISK0}${windows_pn}
    chroot /linux /usr/sbin/mkfs.vfat -F 32 ${DISK0}${windistro_pn}

    # echo "parted -s -- ${DISK0} set 1 boot on || shellout"
    # parted -s -- ${DISK0} set 1 boot on || shellout
    # parted -s -- ${DISK0} mkfs 1 fat32 || shellout
    
    # echo "mkdosfs -F 32 ${DISK0}1 || shellout"
    # /scripts/bin/mkdosfs -F 32 ${DISK0}1 || shellout
    # parted -s -- ${DISK0} resize 1
}

boot_disk_prepare_win10() {
    
    mount_linux
    
    chroot /linux /usr/bin/syslinux ${DISK0}${windows_pn}

    cp -R /a/winpe/* /c/	
}
# -*- mode:shell-script -*-
# Unattend prepare

winxp_unattend_prepare() {

echo "sed /a/netinst/unattend.txt"
sed -e "s:@HOSTNAME@:$HOSTNAME:g" /a/netinst/unattend.txt > /a/netinst/unattend.tmp || shellout
cp -f /a/netinst/unattend.tmp /a/netinst/unattend.txt || shellout
rm /a/netinst/unattend.tmp || shellout

echo "sed /a/netinst/sysprep.inf"
sed -e "s:@HOSTNAME@:$HOSTNAME:g" /a/netinst/sysprep.inf > /a/netinst/sysprep.tmp || shellout
cp -f /a/netinst/sysprep.tmp /a/netinst/sysprep.inf || shellout
rm /a/netinst/sysprep.tmp || shellout

echo "config /netinst/unattend.txt"
cd /a/netinst
. /scripts/unattend.sh

cp /a/netinst/sysprep.inf /a/sysprep/

cd /

}

save_and_clean_mbr ()
{
    dd if=${DISK0} of=/a/netinst/mbr.img count=1 bs=512 || shellout
    /a/ms-sys -m ${DISK0} || shellout
}

create_filesystem_win(){

    echo "Creating partition ${DISK0}1:"

#    echo "parted -s -- ${DISK0} set 1 boot on || shellout"
#    parted -s -- ${DISK0} set 1 boot on || shellout
#    parted -s -- ${DISK0} mkfs 1 fat32 || shellout

    echo "mkdosfs -F 32 ${DISK0}1 || shellout"
    /scripts/bin/mkdosfs -F 32 ${DISK0}1 || shellout
    # parted -s -- ${DISK0} resize 1
}


